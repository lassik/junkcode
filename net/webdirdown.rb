#! /usr/bin/env ruby

# Grab a local copy of a directory tree on a web server by parsing
# HTML directory listings in one of the formats generated by Apache,
# then recreating the directory hierarchy locally and downloading the
# listed files into it.  I use this to download university course
# material.

# Usage: webdirdown http://some/url/

# Downloads into the current directory.  Doesn't do much sanity
# checking.  Existing files are preserved and any like-named remote
# files are skipped.

# One could probably accomplish something similar using wget but it
# was much faster to write this program than to figure out the right
# command line options.  And unlike wget, this program is dead simple
# to use and less verbose.

# Utilities

require "open-uri"

Ent = Struct.new(:name, :type)

def echo(s)
  STDERR.puts(s)
  STDERR.flush
end

def randminmax(min, max)
  min + rand(max - min + 1)
end

def open(*args, &block)
  sleep(randminmax(1, 5)) if args[0] =~ /^http:/
  super(*args, &block)
end

def join(a, b)
  if a.empty? or b.empty? then a + b else File.join(a, b) end
end

# Download and parse HTML directory listing assuming one of the Apache formats
# Subdir : <td><a href="name/">  -> Ent(name, :d)
# File   : <td><a href="name">   -> Ent(name, :f)
def eachent(url, &block)
  open(url) do |input|
    input.read.gsub("\n", " ").scan(/<td><a\s+href=\"(.*?)\">/) do
      case $1
      when /^([^\/]+)\/$/
        block.call(Ent.new($1, :d))
      when /^([^\/]+)$/
        block.call(Ent.new($1, :f))
      else
        # Entry for parent directory; ignore
      end
    end
  end
end

# Core

def downf(baseurl, rel)
  if File.exist?(rel)
    echo("f #{rel} (skipping)")
    return
  end
  echo("f #{rel}")
  relnew = "#{rel}.new"
  begin
    open(join(baseurl, rel), "rb") do |input|
      open(relnew, "wb") do |output|
        n = 1024 * 64
        loop do
          bytes = input.read(n)
          break unless bytes and not bytes.empty?
          output.write(bytes)
        end
      end
    end
    File.rename(relnew, rel)
  rescue OpenURI::HTTPError
    echo("! HTTP error #{$!}")
  end
end

def downd(baseurl, rel = "")
  eachent(join(baseurl, rel)) do |ent|
    subrel = join(rel, ent.name)
    case ent.type
    when :d
      echo("d #{subrel}")
      Dir.mkdir(subrel) unless File.exist?(subrel)
      downd(baseurl, subrel)
    when :f
      downf(baseurl, subrel)
    end
  end
end

def main(url)
  downd(url)
end

begin
  main(*ARGV)
rescue Interrupt
  echo("Interrupted by user")
  exit(1)
end
